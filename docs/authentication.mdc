---
title: Authentication
---

# Authentication

The app uses Google OAuth 2.0 with JWT tokens stored in httpOnly secure cookies for authentication.

## Overview

- **Authentication Method**: Google OAuth 2.0 (OpenID Connect)
- **Token Storage**: JWT tokens in httpOnly, secure, sameSite strict cookies
- **Token Lifetime**: 30 days
- **Security**: Tokens are not accessible to JavaScript (XSS protection)

## Authentication Flow

### 1. User Initiates Login

When a user visits the login page (`LoginPage.tsx`), they can click "Sign in with Google":

1. Client fetches Google Client ID from the public config RPC endpoint (`ConfigService.getPublicConfig`)
2. Client redirects to Google OAuth consent screen:
   ```
   https://accounts.google.com/o/oauth2/v2/auth?
     client_id={GOOGLE_CLIENT_ID}&
     redirect_uri={REDIRECT_URI}&
     response_type=code&
     scope=openid email profile&
     access_type=offline&
     prompt=consent
   ```

### 2. OAuth Callback (`/authentication/oauth/google`)

After the user grants permission, Google redirects back to:
- `GET /authentication/oauth/google?code={authorization_code}`

The server:
1. **Exchanges authorization code for access token**:
   - POST to `https://oauth2.googleapis.com/token`
   - Uses `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`
   
2. **Fetches user info**:
   - GET `https://www.googleapis.com/oauth2/v2/userinfo`
   - Uses the access token as Bearer token
   - Gets user `id`, `email`, and `picture`

3. **Creates JWT token**:
   - Signs JWT with `userId`, `email`, and `picture` (optional)
   - Uses `JWT_SECRET` from environment
   - Sets expiration to 30 days

4. **Sets httpOnly secure cookie**:
   - Cookie name: `authorization`
   - `httpOnly: true` - Not accessible to JavaScript (XSS protection)
   - `secure: true` - Always enabled (HTTPS used in dev and production)
   - `sameSite: 'strict'` - CSRF protection
   - `maxAge: 30 days` (60 * 60 * 24 * 30 seconds)
   - `path: '/'`

5. **Redirects to home page**:
   - Returns HTML with JavaScript redirect to `/`
   - Token is stored in cookie, not in URL or local storage

### 3. Checking Authentication Status (`/api/authentication/get-token`)

To check if a user is authenticated:

```typescript
const response = await fetch('/api/authentication/get-token', {
  credentials: 'include', // Required to send cookies
});
```

The server:
1. Extracts `authorization` cookie from request
2. Verifies JWT using `JWT_SECRET`
3. Returns user info if valid: `{ userId, email, picture }`
4. Returns `401 Unauthorized` if token is missing or invalid

### 4. Authenticated RPC Requests

For Connect RPC services (`PlayerService`, `WorldService`):

1. **Auth Interceptor** (in `server.ts`):
   - Intercepts all Connect RPC requests
   - Checks if service requires authentication (PlayerService, WorldService)
   - Extracts `authorization` cookie
   - Verifies JWT and extracts payload
   - Stores payload in request context under `AUTH_CONTEXT_KEY`
   - Services can access user info via context

2. **Service Implementation**:
   ```typescript
   const authPayload = context.values.get(AUTH_CONTEXT_KEY) as JWTPayload | undefined;
   if (!authPayload) {
     // Handle unauthenticated request
     throw new ConnectError('Unauthorized', Code.Unauthenticated);
   }
   const userId = authPayload.userId;
   ```
   
   **Note**: `WorldService.createWorld` has a fallback mechanism that checks the `Authorization` header if the context is not set (for compatibility), but the primary method is via cookies through the interceptor.

### 5. WebSocket Authentication

WebSocket connections authenticate using the `authorization` cookie:

1. Client connects to `/api/ws/beji-sync` with cookies (automatically sent from same origin)
2. Server extracts and verifies JWT from cookie
3. If invalid or missing, connection is closed with code `1008` (policy violation) and message "Unauthorized: No token" or "Authentication failed"
4. If valid, connection proceeds with authenticated user context
5. Server verifies user ownership of bejis before allowing operations:
   - On `connect` message: Verifies the beji belongs to the authenticated user
   - On `update` message: Verifies the beji belongs to the authenticated user
   - Sends error messages if ownership verification fails

**WebSocket Message Types**:
- `connect`: Client sends `{ type: 'connect', bejiId: string }` to establish connection for a specific beji
- `update`: Client sends `{ type: 'update', bejiId: string, position: { x, y }, target?: { x, y }, walk?: boolean }` to update beji position
- `ping`: Client sends `{ type: 'ping' }` for keepalive, server responds with `{ type: 'pong' }`

### 6. Logout (`POST /authentication/logout`)

To log out:

```typescript
await fetch('/authentication/logout', {
  method: 'POST',
  credentials: 'include',
});
```

The server clears the `authorization` cookie by setting:
- `maxAge: 0` (immediately expires)
- Other cookie attributes remain the same for proper deletion

## Environment Variables

Required environment variables (in `.env.local`):

```bash
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret
JWT_SECRET=your_jwt_secret_key  # Should be a strong random string
```

## Google OAuth Setup

1. Create a project in [Google Cloud Console](https://console.cloud.google.com/)
2. Enable Google+ API
3. Create OAuth 2.0 credentials (OAuth client ID)
4. Configure authorized redirect URIs:
   - Development: `http://localhost:3000/authentication/oauth/google`
   - Production: `https://your-domain.com/authentication/oauth/google`
5. Copy Client ID and Client Secret to `.env.local`

## Security Features

### XSS Protection
- Tokens stored in **httpOnly cookies** - not accessible via `document.cookie` or JavaScript
- Even if XSS vulnerability exists, attacker cannot steal tokens

### CSRF Protection
- Cookies use `sameSite: 'strict'` - only sent with same-site requests
- Cross-site requests cannot include authentication cookies

### HTTPS Protection
- Cookies use `secure: true` always (HTTPS is used in both dev and production)
- Prevents token interception on unencrypted connections

### Token Verification
- JWT tokens are cryptographically signed with `JWT_SECRET`
- Tokens cannot be tampered with without the secret
- Expiration enforced (30 days)

## Implementation Files

- **JWT Functions**: `src/lib/auth/jwt.ts`
  - `signJWT(payload)` - Create JWT token with 30-day expiration
  - `verifyJWT(token)` - Verify and extract payload
  - `JWTPayload` interface: `{ userId: string, email: string, picture?: string, iat?: number, exp?: number }`
  
- **Auth Helper**: `server.ts` (lines 118-134)
  - `authenticateRequest(request)` - Extract and verify cookie token
  - Returns `JWTPayload | null`
  
- **OAuth Routes**: `server.ts` (lines 220-367)
  - `GET /authentication/oauth/google` - OAuth callback handler
  - `GET /api/authentication/get-token` - Check auth status
  - `POST /authentication/logout` - Logout (clears cookie)
  
- **Auth Interceptor**: `server.ts` (lines 170-202)
  - Connect RPC interceptor for authenticated services
  - Automatically extracts JWT from cookies for `PlayerService` and `WorldService`
  - Stores payload in request context via `AUTH_CONTEXT_KEY`
  
- **WebSocket Handler**: `server.ts` (lines 420-563)
  - `/api/ws/beji-sync` - WebSocket endpoint for real-time beji synchronization
  - Authenticates via cookie, verifies beji ownership
  
- **Service Context Key**: `src/lib/rpc/services/playerService.ts` (line 28)
  - `AUTH_CONTEXT_KEY` - Context key for accessing auth payload in RPC services
  - Used by both `PlayerService` and `WorldService`
  
- **Login Page**: `src/pages/LoginPage.tsx`
  - Client-side OAuth initiation
  - Auth status checking on mount
  - Redirects to home if already authenticated

## Testing

Authentication is tested in:
- `tests/auth-jwt.test.ts` - JWT signing and verification, token tampering, expiration, special characters
- `tests/auth-oauth.test.ts` - OAuth flow, callback, token exchange, error handling, cookie security, redirect URI handling

**Test Coverage**:
- JWT creation and verification
- Token tampering detection
- OAuth callback with valid/invalid codes
- Token exchange failures
- User info fetch failures
- Cookie security attributes
- Error handling and redirects
- Get token endpoint with valid/invalid tokens

## Public Config Endpoint

The Google Client ID is served via a public RPC endpoint (`ConfigService.getPublicConfig`), eliminating the need for `NEXT_PUBLIC_` environment variables. This allows:
- Client-side code to get the client ID without exposing it in the bundle
- Server-side control over configuration
- Easy updates without client rebuilds
