---
title: Redis Storage Setup
---

# Redis Storage Setup

This project uses Redis for persistent game state storage in the MMORPG.

## Configuration

Redis connection is configured via the `REDIS_URL` environment variable. Create a `.env.local` file (or set environment variables in your deployment):

```bash
REDIS_URL=redis://red-d4g9n4hr0fns739f93vg:6379
```

### Optional: Authentication

If credentials are not included in the URL, you can set `REDISCLI_AUTH`:

```bash
REDISCLI_AUTH=password
# or
REDISCLI_AUTH=username:password
```

**Note:** Render.com internal Redis uses `redis://` without TLS. The URL format is `redis://red-xxxxx:6379`.

## Redis Provider

This project uses **Render.com internal Redis** service. The Redis URL format is `redis://red-xxxxx:6379` and is provided by Render when you create a Redis service.

## Local Development

### Using Docker
```bash
docker run -d -p 6379:6379 redis:latest
```

### Using Homebrew (macOS)
```bash
brew install redis
brew services start redis
```

## RPC API

Game state operations use RPC (Remote Procedure Calls) via Protocol Buffers. See [RPC documentation](./rpc.mdc) for details on the proto-based API architecture.

### World Service

The primary service for managing worlds:

```typescript
import { createWorld, getWorld } from "@/src/lib/rpc/worldClient";

// Create a world (includes player, beji, and static bejis)
const response = await createWorld("My Beji", [0x1f600]);
const { world, player, beji, staticBeji } = response.world;

// Get a world
const worldData = await getWorld(worldId);
```

**RPC Endpoint**: `POST /api/rpc/world/v1` with `method: "CreateWorld"` or `method: "GetWorld"`

## Data Structure in Redis

Redis stores game data using the following key patterns:

- `beji:gameState` - Full game state (JSON)
- `beji:players` - Set of player IDs
- `beji:player:{playerId}` - Player data (JSON)
- `beji:beji` - Set of beji IDs
- `beji:beji:{bejiId}` - Beji data (JSON)
- `beji:player:{playerId}:beji` - Set of beji IDs for a player
- `beji:worlds` - Set of world IDs
- `beji:world:{worldId}` - World data (JSON)
- `beji:world:{worldId}:staticBeji` - Set of static beji IDs in a world
- `beji:world:{worldId}:beji` - Set of beji IDs in a world
- `beji:staticBeji` - Set of static beji IDs
- `beji:staticBeji:{staticBejiId}` - Static beji data (JSON)
- `beji:inventory:{playerId}` - Inventory data (JSON)

### World Data Structure

A **World** in Redis is represented by multiple keys:

1. **Main World Record** (`beji:world:{worldId}`): JSON string containing:
   ```json
   {
     "id": "world-1234567890",
     "mainBejiId": "beji-1234567890",
     "staticBejiIds": ["static-beji-1", "static-beji-2", ...],
     "createdAt": 1234567890123
   }
   ```

2. **World IDs Set** (`beji:worlds`): Redis SET containing all world IDs

3. **World Static Beji Index** (`beji:world:{worldId}:staticBeji`): Redis SET of static beji IDs in this world

4. **World Beji Index** (`beji:world:{worldId}:beji`): Redis SET of beji IDs in this world

This normalized structure allows:
- Quick lookup of which static bejis belong to a world
- Efficient queries for all entities in a world
- Maintains referential integrity through sets
- Single source of truth for world configuration

## Server-Side Usage

Server-side Redis operations are available via `src/lib/redis/gameState.ts`:

```typescript
import {
    getGameState,
    saveGameState,
    getPlayer,
    savePlayer,
    getAllPlayers,
    saveWorld,
    getWorld,
    saveBeji,
    getBeji,
    saveStaticBeji,
    getStaticBejiForWorld,
    getInventory,
    saveInventory,
    // ... etc
} from "@/src/lib/redis/gameState";
```

These functions are used by the RPC routes and can be imported in server components or API routes. The Redis connection is automatically managed via `getRedisClient()`.
